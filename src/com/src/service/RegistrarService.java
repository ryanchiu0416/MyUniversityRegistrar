package com.src.service;

import com.src.Reference;
import com.src.assigngrade.GradeAssignmentEngine;
import com.src.courseemail.CourseEmailSender;
import com.src.db.QueryEngine;
import com.src.restriction.RestrictionEngine;
import com.src.roster.RosterEngine;
import com.src.schedule.FormatStrategy;
import com.src.schedule.InstructorScheduleFetch;
import com.src.schedule.ScheduleEngine;
import com.src.schedule.StudentScheduleFetch;
import com.src.transcript.TranscriptGenerator;
import com.src.viewgrade.*;
import java.io.FileNotFoundException;
import java.util.List;


/*
    RegistrarService represents the Registrar service interface that clients interact with.
    This class includes all operations available to different clients (student & instructor).

    Pattern: Singleton, Facade.
 */
public class RegistrarService {
    private static RegistrarService instance = null;
    private RegistrarService() {}
    public static RegistrarService getInstance() {
        if (instance == null) {
            instance = new RegistrarService();
        }
        return instance;
    }

    /*
        Student methods
     */
    // overload method for getting single grade
    public String getGrades(int studentID, String courseID) {
        return GradeFetchEngine.getInstance().fetchGrade(new SingleGradeFetch(studentID, courseID));
    }

    // overload method for getting quarterly grade
    public String getGrades(int studentID, Quarter quarter, int academicYear) {
        return GradeFetchEngine.getInstance().fetchGrade(new QuarterlyGradeFetch(studentID, quarter, academicYear));
    }

    // overload method for getting all grades so far
    public String getGrades(int studentID) {
        return GradeFetchEngine.getInstance().fetchGrade(new AllGradeFetch(studentID));
    }


    public String getTranscript(int studentID) {
        return TranscriptGenerator.getInstance().generateTranscript(studentID);
    }


    public String getRestrictions(int studentID) {
        return RestrictionEngine.getInstance().generateRestrictionSummary(studentID);
    }


    public String getClassSchedule(int studentID, FormatStrategy formatter) {
        return "Student Schedule - " + ScheduleEngine.getInstance()
                                        .generateSchedule(studentID, new StudentScheduleFetch(), formatter);
    }



    /*
        Instructor methods
     */
    // Get schedule of current quarter, year.
    public String getTeachingSchedule(int instructorID, FormatStrategy formatter) {
        return "Instructor Schedule - " + ScheduleEngine.getInstance().generateSchedule(instructorID,
                new InstructorScheduleFetch(), formatter);
    }

    // Get Roster of courseID of "current" quarter, year. Design choice logic is that viewing past roster is not needed.
    public String getRoster(int instructorID, String courseID) {
        if (!QueryEngine.getInstance().instrIsPermitted(instructorID, courseID,
            Reference.getQuarter(), Reference.getYear())) {
            return "Permission denied.\n";
        }
        return RosterEngine.getInstance().generateRoster(courseID).toString();
    }

    // Send Email to students in a course of current quarter, year with a message.
    // Design choice logic is that sending email to students in past courses is not needed.
    public String sendClassEmail(int instructorID, String courseID, String message) {
        if (!QueryEngine.getInstance().instrIsPermitted(instructorID, courseID,
            Reference.getQuarter(), Reference.getYear())) {
            return "Permission denied.\n";
        }
        return CourseEmailSender.getInstance().sendEmail(instructorID, message, courseID);
    }

    // View grades in a course taught in past/teaching now (specified by quarter, year).
    // Design choice is that sometimes retrieving grades from courses in previous quarter is needed.
    public String generateGradeSheet(int instructorID, String courseID,
                                     Quarter q, int year) throws FileNotFoundException {
        if (!QueryEngine.getInstance().instrIsPermitted(instructorID, courseID, q, year)) {
            return "Permission denied.\n";
        }
        return GradeAssignmentEngine.getInstance().generateGradeSheet(courseID, q, year);
    }

    // Update grades in a gradesheet file (specified by a filepath) for a course taught in past/teaching now
    // (specified by quarter, year).
    // Design choice is that sometimes modifying grades from courses in previous quarter is needed.
    // Gradesheet file should follow the same format as it was generated by generateGradeSheet().
    public String updateGrades(int instructorID, String courseID, String filePath,
                               Quarter q, int year) throws FileNotFoundException {
        if (!QueryEngine.getInstance().instrIsPermitted(instructorID, courseID, q, year)) {
            return "Permission denied.\n";
        }
        return GradeAssignmentEngine.getInstance().importGradesFromFile(courseID, filePath, q, year);
    }

    // To retrieve all courses taught in the past / teaching now.
    public String getAllCourseTaught(int instructorID) {
        List<String[]> lst = QueryEngine.getInstance().instrGetCourseTaughtHistory(instructorID);
        if (lst.isEmpty()) {
            return "No course taught or teaching.\n";
        }
        String res = "All course taught / teaching:\n";
        for (String[] item : lst) {
            res += "\t"+ item[0] + " in " + item[1].toUpperCase() + " " + item[2] + ",\n";
        }
        return res.substring(0, res.length()-2) + ".\n";
    }
}
